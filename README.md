# GraphAnalysisCostOptimization
Graph-based project: Determining regions and finding optimal routes using depth-first search and Dijkstra's algorithm.

#Task1: The graph representing the map is an undirected graph, where the city objectives are represented as nodes, and the bidirectional roads between these nodes are represented as edges. Each road has a specific distance associated with it. The first goal is to determine the number of regions. A region consists of all nodes in the graph connected to each other. Logic and implementation method: The number of regions is determined using an implementation of the depth-first search (DFS) algorithm. In the dfsRecursive function, we initialize a visited vector of size N (the number of nodes in the graph) and a regionSizes vector of size N to track the size of each region. We call the dfsRecHelper function for each unvisited node in the graph. In dfsRecHelper, we mark the current node as visited, increase sizeofReg (the size of the current region), and add the node to a path queue that stores the path taken during the DFS traversal. Inside the for loop, we traverse the adjacency list of the current node, and for each unvisited neighbor, we recursively call dfsRecHelper. This way, we traverse all connected nodes and form a region. After the DFS traversal (helper) for a region is completed, we increase the number of regions (regions++). For each region separated by water bodies, we need to determine the minimum total cost of roads that should be renovated. After the DFS traversal for a region is completed, we use the Prim's algorithm to determine the minimum cost of roads that need to be renovated in that region. Prim's algorithm is applied to the corresponding subgraph of the region, with a starting node and a previously calculated size (the number of nodes in the region).

#Task2: According to the found map, there is an island at a considerable distance from the shore, where the water depth is insufficient in certain places. To solve this situation, the crew needs to use a boat to transport the treasure from the island to the ship. The map indicates the safe zones through which the boat can pass. The direction of travel between two zones is specified, making the graph directed. During the formation of the island, sand dunes have also formed on the routes indicated on the map. Before starting to load the treasure onto the ship, the crew analyzes the route from the island to the ship and marks the sand dunes. Each node on the map has a value representing the water depth at that point. As the boat is loaded with more cargo, it sinks deeper, making it difficult to traverse certain areas. Given the limited time and crew exhaustion, the best option for transporting the treasure needs to be found. Formula for assigning a score to each arc based on distance and depth. The score is used to evaluate each option and, ultimately, to determine the best route to transport the treasure from the island to the ship. Once the route is chosen, it cannot be changed. Ideally, we are looking for the shortest routes that allow the transportation of as much valuable goods as possible. The formula used for evaluating an arc is: score(arc) = distance(arc) / depth(node_to_which_the_arc_goes). We need to check the existence of at least one route through which we can reach from the Ship to the Island. Otherwise, the message "The crew cannot reach the island" will be displayed, and the problem will be concluded. In the situation where we find a route from the Ship to the Island, but there is no route from the Island to the Ship, the message "The crew cannot transport the treasure back to the ship" will be displayed. Implementation method: The main function read_graph2 receives three parameters: the input file name, a TGraphL structure, and a variable gold

Weight (the weight of the treasure). The purpose of this function is to read the graph information from the input file and construct the corresponding adjacency list of the graph. To achieve this, the function reads the number of nodes and the number of edges from the file. Then, the alloc_graph function is used to initialize the graph with the correct number of nodes. The next step is to read each edge from the file. To determine the corresponding indices for each node, a vector of strings and a vector of indices are used. After obtaining the indices for each node, the insert_edge_list2 function is used to insert the edges into the adjacency list of the graph. In addition to reading the edges, the read_graph2 function also reads additional information about the depth of each node and the associated gold weight. After the graph has been read and constructed, we use Dijkstra's algorithm and the dijkstra function to calculate the results. To check if there is a path from the destination to the source in the graph, the hasPathToSourceDFS function is used. Dijkstra's algorithm is applied to the given graph to find the shortest path from the source to the destination. It determines the minimum distances (actually, by minimum distance, I refer to the respective score) from the source node to all other nodes in the graph. After calculating the minimum distances, the total cost of the shortest path is calculated using the edge costs, and the results are displayed in an output file. Although the hasPathToSourceDFS function is a recursive function that checks if there is a path from a destination node back to the source in a graph represented using the adjacency list, I used it to check if there is a path from the possible current node to the destination in the algorithm when applying the score. It should only be applied if there is a guaranteed path from the possible node to the destination (i.e., the ship). However, I couldn't think of an implementation like that to correctly store the costs, depths, and the ratio at the same time, so I thought of an alternative implementation. I used the Dijkstra's algorithm based on initial costs.
